## 杨辉三角

![image-20230321210553189](https://raw.githubusercontent.com/pkxzs/PicBed/main/Img/image-20230321210553189.png)

**性质1： 每行的第二个数是逐渐递增的**

**性质2：若一行第二个数为n，则第三个数为n(n - 1)/2**



题：如果我们按从上到下、从左到右的顺序把所有数排成一列，可以得到如下数列： 1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,⋯1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,⋯

给定一个正整数 �*N*，请你输出数列中第一次出现 �*N* 是在第几个数？

```c#include <iostream>
#include <iostream>
using namespace std;
long long a[100010],b[100010];//开两个数组，一个保存上一行那一半的数，一个保存目的行那一半的数
int main()
{
  a[0]=1;
  b[0]=1;
  long long n;
  cin>>n;
  if(n==1){
    cout<<1;
    return 0;
  }
  for(int i=3;i<=44723;i++){//这个是最高循环次数，你可以自己找
    int m=i/2;//只要一半
    for(int j=1;j<=m;j++){
        if(j==m&&i%2==1){//如果行数为奇数那么就有个中间数，就是上一行前面数的两倍
            b[j]=a[j-1]*2;
        }
        else{
            b[j]=a[j-1]+a[j];//杨辉三角
        }
        a[j-1]=b[j-1];//更新a数组
        if(b[j]==n){
            cout<<i*(i-1)/2+j+1;//输出
            return 0;
        }
    }
    a[m]=b[m];//更新a数组
  }
  cout<<n*(n+1)/2+2;//防止溢出
  return 0;
}

```

**问题：找一个数在杨辉三角中第一次出现的位置**

* 根据性质二计算这个数取值最大时，杨辉三角的第三个数比这个数最大值大时的行数
* 用循环从第三行开始，前两行全为1，到计算的行数为止
* ==杨辉三角是递增的，但不是连续递增==
* 若循环完后依然找不到目标数，那么目标数一定为大于计算行数的某一行的第二个数，因为循环中的最后一行的三个数是大于目标数的，又因为第三个数又可以根据性质2得到，则若循环中没有目标数且目标又小于循环最后一行的第三个数，而且之后每一行的第三个数都是大于循环中的第三个数，所以目标不在循环中则肯定在一行的第二个数
* 因为杨辉三角的第二个数是等差数列，所以目标数一定是第n+1行的第二个数